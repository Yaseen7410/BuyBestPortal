{"ast":null,"code":"/* tslint:disable */\n\n/* eslint-disable */\n//----------------------\n// <auto-generated>\n//     Generated using the NSwag toolchain v13.3.0.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)\n// </auto-generated>\n//----------------------\n// ReSharper disable InconsistentNaming\nimport { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\nimport { InjectionToken } from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport const API_BASE_URL = new InjectionToken('API_BASE_URL');\nexport let AccountClient = /*#__PURE__*/(() => {\n  class AccountClient {\n    constructor(http, baseUrl) {\n      this.jsonParseReviver = undefined;\n      this.http = http;\n      this.baseUrl = baseUrl ? baseUrl : \"\";\n    }\n\n    registerRequest(command) {\n      let url_ = this.baseUrl + \"/api/Account/registerRequest\";\n      url_ = url_.replace(/[?&]$/, \"\");\n      const content_ = JSON.stringify(command);\n      let options_ = {\n        body: content_,\n        observe: \"response\",\n        responseType: \"blob\",\n        headers: new HttpHeaders({\n          \"Content-Type\": \"application/json\",\n          \"Accept\": \"application/json\"\n        })\n      };\n      return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap(response_ => {\n        return this.processRegisterRequest(response_);\n      })).pipe(_observableCatch(response_ => {\n        if (response_ instanceof HttpResponseBase) {\n          try {\n            return this.processRegisterRequest(response_);\n          } catch (e) {\n            return _observableThrow(e);\n          }\n        } else return _observableThrow(response_);\n      }));\n    }\n\n    processRegisterRequest(response) {\n      const status = response.status;\n      const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n      let _headers = {};\n\n      if (response.headers) {\n        for (let key of response.headers.keys()) {\n          _headers[key] = response.headers.get(key);\n        }\n      }\n\n      ;\n\n      if (status === 200) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          let result200 = null;\n          let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\n          result200 = Result.fromJS(resultData200);\n          return _observableOf(result200);\n        }));\n      } else if (status !== 200 && status !== 204) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n        }));\n      }\n\n      return _observableOf(null);\n    }\n\n    loginRequest(command) {\n      let url_ = this.baseUrl + \"/api/Account/loginRequest\";\n      url_ = url_.replace(/[?&]$/, \"\");\n      const content_ = JSON.stringify(command);\n      let options_ = {\n        body: content_,\n        observe: \"response\",\n        responseType: \"blob\",\n        headers: new HttpHeaders({\n          \"Content-Type\": \"application/json\",\n          \"Accept\": \"application/json\"\n        })\n      };\n      return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap(response_ => {\n        return this.processLoginRequest(response_);\n      })).pipe(_observableCatch(response_ => {\n        if (response_ instanceof HttpResponseBase) {\n          try {\n            return this.processLoginRequest(response_);\n          } catch (e) {\n            return _observableThrow(e);\n          }\n        } else return _observableThrow(response_);\n      }));\n    }\n\n    processLoginRequest(response) {\n      const status = response.status;\n      const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n      let _headers = {};\n\n      if (response.headers) {\n        for (let key of response.headers.keys()) {\n          _headers[key] = response.headers.get(key);\n        }\n      }\n\n      ;\n\n      if (status === 200) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          let result200 = null;\n          let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\n          result200 = Result.fromJS(resultData200);\n          return _observableOf(result200);\n        }));\n      } else if (status !== 200 && status !== 204) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n        }));\n      }\n\n      return _observableOf(null);\n    }\n\n  }\n\n  AccountClient.ɵfac = function AccountClient_Factory(t) {\n    return new (t || AccountClient)(i0.ɵɵinject(HttpClient), i0.ɵɵinject(API_BASE_URL, 8));\n  };\n\n  AccountClient.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AccountClient,\n    factory: AccountClient.ɵfac,\n    providedIn: 'root'\n  });\n  return AccountClient;\n})();\nexport class Result {\n  constructor(data) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property)) this[property] = data[property];\n      }\n    }\n  }\n\n  init(_data) {\n    if (_data) {\n      this.succeeded = _data[\"succeeded\"];\n\n      if (Array.isArray(_data[\"errors\"])) {\n        this.errors = [];\n\n        for (let item of _data[\"errors\"]) this.errors.push(item);\n      }\n\n      this.lists = _data[\"lists\"];\n    }\n  }\n\n  static fromJS(data) {\n    data = typeof data === 'object' ? data : {};\n    let result = new Result();\n    result.init(data);\n    return result;\n  }\n\n  toJSON(data) {\n    data = typeof data === 'object' ? data : {};\n    data[\"succeeded\"] = this.succeeded;\n\n    if (Array.isArray(this.errors)) {\n      data[\"errors\"] = [];\n\n      for (let item of this.errors) data[\"errors\"].push(item);\n    }\n\n    data[\"lists\"] = this.lists;\n    return data;\n  }\n\n}\nexport class RegisterDTO {\n  constructor(data) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property)) this[property] = data[property];\n      }\n    }\n  }\n\n  init(_data) {\n    if (_data) {\n      this.id = _data[\"id\"];\n      this.name = _data[\"name\"];\n      this.email = _data[\"email\"];\n      this.address = _data[\"address\"];\n      this.password = _data[\"password\"];\n    }\n  }\n\n  static fromJS(data) {\n    data = typeof data === 'object' ? data : {};\n    let result = new RegisterDTO();\n    result.init(data);\n    return result;\n  }\n\n  toJSON(data) {\n    data = typeof data === 'object' ? data : {};\n    data[\"id\"] = this.id;\n    data[\"name\"] = this.name;\n    data[\"email\"] = this.email;\n    data[\"address\"] = this.address;\n    data[\"password\"] = this.password;\n    return data;\n  }\n\n}\nexport class RegisterCommad extends RegisterDTO {\n  constructor(data) {\n    super(data);\n  }\n\n  init(_data) {\n    super.init(_data);\n  }\n\n  static fromJS(data) {\n    data = typeof data === 'object' ? data : {};\n    let result = new RegisterCommad();\n    result.init(data);\n    return result;\n  }\n\n  toJSON(data) {\n    data = typeof data === 'object' ? data : {};\n    super.toJSON(data);\n    return data;\n  }\n\n}\nexport class LoginDTO {\n  constructor(data) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property)) this[property] = data[property];\n      }\n    }\n  }\n\n  init(_data) {\n    if (_data) {\n      this.name = _data[\"name\"];\n      this.password = _data[\"password\"];\n    }\n  }\n\n  static fromJS(data) {\n    data = typeof data === 'object' ? data : {};\n    let result = new LoginDTO();\n    result.init(data);\n    return result;\n  }\n\n  toJSON(data) {\n    data = typeof data === 'object' ? data : {};\n    data[\"name\"] = this.name;\n    data[\"password\"] = this.password;\n    return data;\n  }\n\n}\nexport class LoginCommand extends LoginDTO {\n  constructor(data) {\n    super(data);\n  }\n\n  init(_data) {\n    super.init(_data);\n  }\n\n  static fromJS(data) {\n    data = typeof data === 'object' ? data : {};\n    let result = new LoginCommand();\n    result.init(data);\n    return result;\n  }\n\n  toJSON(data) {\n    data = typeof data === 'object' ? data : {};\n    super.toJSON(data);\n    return data;\n  }\n\n}\nexport class SwaggerException extends Error {\n  constructor(message, status, response, headers, result) {\n    super();\n    this.isSwaggerException = true;\n    this.message = message;\n    this.status = status;\n    this.response = response;\n    this.headers = headers;\n    this.result = result;\n  }\n\n  static isSwaggerException(obj) {\n    return obj.isSwaggerException === true;\n  }\n\n}\n\nfunction throwException(message, status, response, headers, result) {\n  if (result !== null && result !== undefined) return _observableThrow(result);else return _observableThrow(new SwaggerException(message, status, response, headers, null));\n}\n\nfunction blobToText(blob) {\n  return new Observable(observer => {\n    if (!blob) {\n      observer.next(\"\");\n      observer.complete();\n    } else {\n      let reader = new FileReader();\n\n      reader.onload = event => {\n        observer.next(event.target.result);\n        observer.complete();\n      };\n\n      reader.readAsText(blob);\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"module"}